# クライアント側再接続機能 - テストケース定義書

## 機能名
**クライアント側 WebSocket 再接続機能**

---

## 開発言語・フレームワーク

🔵 **青信号** (既存技術スタックから確認)

- **プログラミング言語**: TypeScript 5.x
  - **言語選択の理由**: 既存プロジェクトがTypeScriptで統一されており、型安全性が確保される
  - **テストに適した機能**: 型定義によりテストコードの誤りを早期発見できる

- **テストフレームワーク**: Vitest + React Testing Library
  - **フレームワーク選択の理由**:
    - Vitestはプロジェクトの既存選択（tech-stack.mdより）
    - React Testing Libraryはコンポーネントテストの標準
    - Socket.ioのモック化が容易
  - **テスト実行環境**: Node.js 20.x LTS環境、JSDOMでブラウザ環境をシミュレート

- **モックライブラリ**: vitest/vi (Vitest組み込み)
  - Socket.ioクライアントのモック化
  - localStorageのモック化
  - Timerのモック化（グレースピリオドテスト用）

---

## テストケースの分類

### 1. 正常系テストケース（基本的な動作）

#### TC-01: Socket切断時に再接続UIが表示される

🔵 **青信号** (要件定義書から確認)

- **テスト名**: Socket切断時に再接続モーダルが表示される
  - **何をテストするか**: Socket の `disconnect` イベント発火時に再接続中UIが表示されること
  - **期待される動作**: モーダルに「再接続中...」というメッセージとローディングスピナーが表示される

- **入力値**:
  - Socket.io の `disconnect` イベントをトリガー
  - **入力データの意味**: ネットワーク切断やサーバー停止をシミュレート

- **期待される結果**:
  - 再接続モーダルが表示される
  - モーダル内に「再接続中...」テキストが存在する
  - ローディングスピナーが表示される
  - **期待結果の理由**: ユーザーに現在の状態を明示し、不安を軽減する

- **テストの目的**: UI表示の即応性を確認
  - **確認ポイント**: 切断検知から100ms以内にUIが応答すること（パフォーマンス要件）

---

#### TC-02: 再接続成功時にlocalStorageから情報を取得してreconnectRequestを送信

🔵 **青信号** (要件定義書のデータフローから確認)

- **テスト名**: Socket再接続成功時にreconnectRequestイベントが送信される
  - **何をテストするか**: Socket の `connect` イベント発火時に、localStorage から playerId/roomId を取得し、reconnectRequest を送信すること
  - **期待される動作**: 適切なパラメータで reconnectRequest イベントがサーバーに送信される

- **入力値**:
  - localStorage に保存された `{ playerId: 'player-123', roomId: 'room-456' }`
  - Socket.io の `connect` イベントをトリガー
  - **入力データの意味**: ページリロードやネットワーク復帰後のシナリオを再現

- **期待される結果**:
  - `socket.emit('reconnectRequest', { playerId: 'player-123', roomId: 'room-456' })` が呼ばれる
  - **期待結果の理由**: サーバー側でセッション検証を行うために必要な情報を送信

- **テストの目的**: 再接続フローの正確性を確認
  - **確認ポイント**: localStorage の値が正しく読み取られ、イベントパラメータに反映されること

---

#### TC-03: gameStateイベント受信時にゲーム状態が復元される

🔵 **青信号** (要件定義書の入力パラメータから確認)

- **テスト名**: gameStateイベント受信時に GameContext が更新される
  - **何をテストするか**: サーバーからの `gameState` イベント受信時に、GameContext の各状態が正しく復元されること
  - **期待される動作**: players, communityCards, pot, currentBettorId, playerBets, myHand が全て更新される

- **入力値**:
  ```typescript
  {
    roomId: 'room-456',
    players: [
      { id: 'player-123', name: 'Alice', chips: 980, seat: 0 },
      { id: 'player-789', name: 'Bob', chips: 1020, seat: 1 }
    ],
    communityCards: ['Ah', 'Kd', 'Qs'],
    pot: 50,
    currentBettorId: 'player-789',
    playerBets: { 'player-123': 20, 'player-789': 30 },
    hand: ['Tc', 'Td']
  }
  ```
  - **入力データの意味**: フロップ（Flop）段階でのゲーム状態を表す

- **期待される結果**:
  - GameContext の各プロパティが入力値と一致する
  - 再接続モーダルが閉じる
  - **期待結果の理由**: ユーザーが切断前の状態から正確に再開できる

- **テストの目的**: 状態復元の完全性を確認
  - **確認ポイント**: 全てのゲーム状態プロパティが漏れなく復元されること

---

#### TC-04: ブラウザリフレッシュ後の自動復帰

🟡 **黄信号** (要件定義書のケース2から推測)

- **テスト名**: ページリロード後、localStorageから情報を取得して自動再接続
  - **何をテストするか**: SocketContext 初期化時に localStorage に playerId/roomId があれば、接続後に自動的に reconnectRequest を送信すること
  - **期待される動作**: ユーザーの明示的なアクションなしに再接続フローが開始される

- **入力値**:
  - localStorage: `{ playerId: 'player-123', roomId: 'room-456' }`
  - SocketProvider をマウント
  - `connect` イベントを発火
  - **入力データの意味**: F5キーやブラウザの再読み込みボタンによるページリフレッシュ

- **期待される結果**:
  - `reconnectRequest` イベントが自動送信される
  - ユーザーは再接続モーダルを見た後、ゲーム画面に復帰する
  - **期待結果の理由**: 誤操作によるページリロードからの復帰をシームレスに行う

- **テストの目的**: localStorage統合の正確性を確認
  - **確認ポイント**: ページ再読み込み時に自動的に再接続フローが発動すること

---

### 2. 異常系テストケース（エラーハンドリング）

#### TC-05: reconnectRequest失敗時にエラーメッセージを表示してロビーへ遷移

🔵 **青信号** (要件定義書のエラーケースから確認)

- **テスト名**: RECONNECT_FAILED エラー受信時の処理
  - **エラーケースの概要**: グレースピリオド超過などでサーバーが再接続を拒否した場合
  - **エラー処理の重要性**: ユーザーに状況を説明し、適切な次のアクションを示す

- **入力値**:
  - `error` イベント: `{ message: 'Reconnection failed - grace period expired', code: 'RECONNECT_FAILED' }`
  - **不正な理由**: 120秒のグレースピリオドを超過してセッションが無効化された
  - **実際の発生シナリオ**: 長時間のネットワーク切断、デバイスのスリープ復帰

- **期待される結果**:
  - エラーメッセージ「セッションが期限切れです」が表示される
  - localStorage から playerId/roomId がクリアされる
  - ロビー画面 (`/`) へ自動遷移する
  - **エラーメッセージの内容**: ユーザーフレンドリーで、再度ロビーから参加できることを示唆
  - **システムの安全性**: 無効なセッション情報が残らないようlocalStorageをクリア

- **テストの目的**: エラー時のグレースフルデグラデーションを確認
  - **品質保証の観点**: エラー時でもユーザーが次の行動を理解でき、システムが安全な状態に戻る

---

#### TC-06: localStorageにplayerIdが存在しない場合の処理

🟡 **黄信号** (要件定義書のエラーケース6から推測)

- **テスト名**: localStorage が空の場合、reconnectRequest を送信しない
  - **エラーケースの概要**: 初回訪問やlocalStorageクリア後のシナリオ
  - **エラー処理の重要性**: 不要なサーバーリクエストを防ぎ、エラーログを削減

- **入力値**:
  - localStorage: null (または空)
  - `connect` イベントを発火
  - **不正な理由**: 再接続すべきセッション情報が存在しない
  - **実際の発生シナリオ**: 初回アクセス、プライベートブラウジング、手動削除

- **期待される結果**:
  - `reconnectRequest` イベントが送信されない
  - 再接続モーダルが表示されない
  - 通常の接続状態として処理される
  - **システムの安全性**: 無効なリクエストでサーバーに負荷をかけない

- **テストの目的**: 初期状態での安全性確認
  - **品質保証の観点**: エッジケースでもシステムが安定動作すること

---

#### TC-07: Socket.io自動再接続が10回失敗した場合のフォールバック

🟡 **黄信号** (要件定義書のエラーケース5と制約条件から推測)

- **テスト名**: 再接続試行回数超過時のエラー表示
  - **エラーケースの概要**: サーバーダウンや長時間のネットワーク障害
  - **エラー処理の重要性**: 永久にリトライを続けず、ユーザーに状況を伝える

- **入力値**:
  - Socket.io の `reconnect_failed` イベント (10回試行後)
  - **不正な理由**: サーバーが応答不能、または完全なネットワーク切断
  - **実際の発生シナリオ**: サーバーメンテナンス、ISP障害、デバイスの機内モード

- **期待される結果**:
  - 「サーバーに接続できません」エラーメッセージ表示
  - ロビーへ遷移するオプションを表示
  - **エラーメッセージの内容**: 技術的問題であることを明示し、後で再試行を促す
  - **システムの安全性**: 無限リトライを防ぎ、ユーザーに制御を返す

- **テストの目的**: 回復不能なエラー時の動作確認
  - **品質保証の観点**: システムがハングせず、ユーザーが別の行動を選択できる

---

### 3. 境界値テストケース

#### TC-08: グレースピリオドちょうど120秒での再接続

🟡 **黄信号** (要件定義書の制約条件から推測)

- **テスト名**: グレースピリオド境界値（120秒）での再接続成功
  - **境界値の意味**: サーバー側の `GRACE_PERIOD` 定数値（120000ms）
  - **境界値での動作保証**: 120秒ぴったりで再接続した場合の挙動

- **入力値**:
  - 切断から119.9秒後に reconnectRequest 送信
  - サーバーから `gameState` イベント受信
  - **境界値選択の根拠**: サーバー側の SessionManager.reconnect() が 120秒以内かチェックする
  - **実際の使用場面**: ネットワーク復帰がグレースピリオド終了直前のケース

- **期待される結果**:
  - 再接続成功
  - ゲーム状態が復元される
  - **境界での正確性**: 120秒未満であれば確実に成功すること
  - **一貫した動作**: 119秒でも121秒でもない、ちょうど120秒での動作確認

- **テストの目的**: 境界値での堅牢性確認
  - **堅牢性の確認**: タイミング依存のバグがないこと

---

#### TC-09: グレースピリオド超過（120.1秒）での再接続失敗

🟡 **黄信号** (要件定義書の制約条件から推測)

- **テスト名**: グレースピリオド超過時の再接続拒否
  - **境界値の意味**: グレースピリオドの上限を超えた場合
  - **境界値での動作保証**: 120秒を1msでも超えたら失敗すること

- **入力値**:
  - 切断から120.1秒後に reconnectRequest 送信
  - サーバーから `error` イベント（RECONNECT_FAILED）受信
  - **境界値選択の根拠**: SessionManager のグレースピリオドチェックロジック
  - **実際の使用場面**: ネットワーク復帰が僅かに遅れたケース

- **期待される結果**:
  - 再接続失敗
  - エラーメッセージ表示
  - ロビーへ遷移
  - **境界での正確性**: 120秒を超えたら確実に失敗すること
  - **一貫した動作**: サーバー側のロジックと完全に一致

- **テストの目的**: 境界値での明確な挙動確認
  - **堅牢性の確認**: グレースピリオドが厳密に守られること

---

#### TC-10: localStorage の playerId が null の場合

🔵 **青信号** (一般的な境界値テストから確認)

- **テスト名**: localStorage.getItem が null を返す場合の処理
  - **境界値の意味**: localStorage に該当キーが存在しない場合の戻り値
  - **境界値での動作保証**: null チェックが正しく機能すること

- **入力値**:
  - `localStorage.getItem('playerId')` が `null` を返す
  - **境界値選択の根拠**: JavaScript の localStorage API仕様
  - **実際の使用場面**: 初回訪問、localStorage クリア後

- **期待される結果**:
  - `reconnectRequest` イベントが送信されない
  - エラーが発生しない（nullチェックが機能）
  - **境界での正確性**: null値を安全に処理できること
  - **一貫した動作**: undefined や空文字列も同様に安全に処理

- **テストの目的**: null安全性の確認
  - **堅牢性の確認**: 予期しないnull値でクラッシュしないこと

---

#### TC-11: 空の gameState を受信した場合

🟡 **黄信号** (異常なサーバーレスポンスのケースを想定)

- **テスト名**: 不完全な gameState データの処理
  - **境界値の意味**: サーバーエラーや通信エラーで一部データが欠落
  - **境界値での動作保証**: 必須フィールドの欠損を検出すること

- **入力値**:
  - `gameState` イベント: `{ roomId: 'room-456', players: [] }` (他のフィールドが欠落)
  - **境界値選択の根拠**: ネットワークエラーやサーバーバグによる不完全データ
  - **実際の使用場面**: サーバー障害、通信途中切断

- **期待される結果**:
  - エラーメッセージ「ゲーム状態の復元に失敗しました」を表示
  - ロビーへ遷移
  - **境界での正確性**: 不完全なデータでGameContextを破壊しないこと
  - **一貫した動作**: バリデーションエラーとして適切に処理

- **テストの目的**: データ整合性の確認
  - **堅牢性の確認**: 不正なデータでもクラッシュせず、安全にフォールバックすること

---

## テストケース実装時の日本語コメント指針

各テストケースには以下のコメントを必ず含めます：

### テストケース開始時

```typescript
// 【テスト目的】: Socket切断時に再接続モーダルが表示されることを確認
// 【テスト内容】: disconnect イベント発火時のUI表示をテスト
// 【期待される動作】: 「再接続中...」モーダルとローディングスピナーが表示される
// 🔵 要件定義書の「再接続中表示」仕様から確認
```

### Given（準備フェーズ）

```typescript
// 【テストデータ準備】: Socket.ioクライアントのモックを作成
// 【初期条件設定】: SocketContextとGameContextをマウント
// 【前提条件確認】: 正常に接続された状態から開始
```

### When（実行フェーズ）

```typescript
// 【実際の処理実行】: Socket の disconnect イベントをトリガー
// 【処理内容】: ネットワーク切断をシミュレート
// 【実行タイミング】: コンポーネントマウント後、100ms以内
```

### Then（検証フェーズ）

```typescript
// 【結果検証】: 再接続モーダルが画面に表示されているか確認
// 【期待値確認】: 「再接続中...」テキストとスピナーの存在を検証
// 【品質保証】: ユーザーに状態を明示し、不安を軽減する
```

---

## テスト実装の優先順位

### Phase 1: 必須テスト（MVP）
1. TC-01: Socket切断時の UI表示
2. TC-02: reconnectRequest の送信
3. TC-03: gameState による状態復元
4. TC-05: エラー時のロビー遷移

### Phase 2: エッジケース
5. TC-04: ブラウザリフレッシュ後の復帰
6. TC-06: localStorage 空の場合
7. TC-07: 再接続試行回数超過

### Phase 3: 境界値テスト
8. TC-08: グレースピリオド境界（120秒）
9. TC-09: グレースピリオド超過
10. TC-10: localStorage null 処理
11. TC-11: 不完全な gameState

---

## モック戦略

### Socket.ioクライアントのモック

```typescript
// 【モック理由】: 実際のSocket.ioサーバー接続なしでテスト可能にする
const mockSocket = {
  on: vi.fn(),
  emit: vi.fn(),
  connected: true,
  disconnect: vi.fn(),
};

vi.mock('socket.io-client', () => ({
  io: vi.fn(() => mockSocket),
}));
```

### localStorageのモック

```typescript
// 【モック理由】: ブラウザ環境がない Node.js でテスト実行可能にする
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn(),
};

global.localStorage = localStorageMock as any;
```

### React Routerのモック

```typescript
// 【モック理由】: ナビゲーション動作を検証可能にする
const mockNavigate = vi.fn();

vi.mock('react-router-dom', () => ({
  useNavigate: () => mockNavigate,
}));
```

---

## 品質判定

### 判定結果: ✅ **高品質**

#### 理由
- ✅ **テストケース分類**: 正常系4件、異常系3件、境界値4件で網羅的
- ✅ **期待値定義**: 全テストケースで期待値と理由が明確
- ✅ **技術選択**: Vitest + React Testing Libraryで確定、既存スタックと一致
- ✅ **実装可能性**: 全てのケースでモック戦略が明確、実装可能

#### カバレッジ目標
- **ユニットテスト**: 70%以上（tech-stack.mdのクライアント目標値）
- **対象コンポーネント**:
  - SocketContext の再接続ロジック
  - GameContext の状態復元ロジック
  - 再接続モーダルコンポーネント

---

## 次のステップ

テストケースの洗い出しが完了しました。次は以下のコマンドでRedフェーズ（失敗テスト作成）を開始します：

```
/tsumiki:tdd-red
```

---

## 変更履歴

| 日付 | バージョン | 変更内容 |
|------|-----------|---------|
| 2025-11-23 | 1.0 | 初版作成（milestone-b クライアント側テストケース） |
